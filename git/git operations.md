Local operations

- для создания новой папки:
	$mkdir newfolder
- для создания файла:
	$touch newfile
- для создания локального Git репозитория в текущей директории:
	$git init
- для просмотра статуса репозитория можно воспользоваться:
	$git status
	В результате будут отображены не отслеживаемые файлы.
- для добавления новых файлов в staged area используется:
	$git stage/add . - добавление всех файлов
	$git stage/add file - добавление file в stage area
- для фиксации изменений :
	$git commit -m "Commit message"
- для просмотра истории:
	$git log
- для просмотра изменений коммит можно использовать:
	$git show
	В результате помимо автора, даты и названия коммита будут отображаться изменения.
- для удаления файла используется:
	$rm file - удаляет файл
	$git rm file - удаляет файл и добавляет изменения в stage area
- для сброса отслеживаемого файла (который был в staged или commited)
	$git reset HEAD~1
- для удаления файла из staging area используется:
	$git reset  file
- для редактирования сообщения последнего коммита применяется:
	$git commit --amend "New message"
	При использовании этой команды создается новый Git ID, поэтому ее следует применять только для коммитов, которые не были запушены в другой Git репозиторий.

Remote repositories

- для клонирования удаленного репозитория используются:
	$git clone ssh://git@github.com/account/repository.git - новый способ клонирования через ssh
	$git clone git@github.com:account/reposiory.git - клонирование через ssh
	$git clone http://github.com/account/repository.git клонирование через http
- можно добавить дополнительный удаленный репозиторий при помощи:
	$git remote add name repo_link
	По умолчанию при клонировании репозитория создается удаленный с именем origin и при наличии прав в него можно пушить локальные изменения.
- переименовать удаленный репозиторий можно используя:
	$git remote rename old_name new_name
- для добавления удаленного репозитория при создании своего с нуля (без клонирования) используется:
	$git remote add origin link
- для отправки измнений в удаленный репозиторий используется:
	$git push origin
- для просмотра удаленных репозиториев применяется:
	$git remote show origin - отображает информацию об удаленном репозитории origin
	$git remote - отображает удаленные репозитории
	$git remote -v - отображает более детальную информацию о детальных репозиториях
- для обновления текущей ветки локального репозитория из удаленного репозитория применяется:
	$git pull

Using branches

- для отображения ветвей используются:
	$git branch - выводит список локальных ветвей
	$git branch -a - выводит список локальных и отслеживаемых удаленных ветвей
	$git branch -v - выводит список локальных ветвей с более подробной информацией
	$git  branch -r - выводит список отслеживаемых удаленных ветвей
	Перечисленные параметры можно комбинировать при построении команды.
- для создания новой ветки применяется:
	$git branch new_branch_name
- для переключения текущей ветви используется:
	$git checkout branch_name - переключает на ветку branch_name
	$git checkout -b new_branch_name - создает новую ветку new_branch_name и выбирает ее как текущую
	$git checkout -b new_branch_name branch_name - создает ветвь new_branch_name на основе branch_name
	В случае незафиксированных изменений они будут переноситься в переключаемую ветвь, так как не принадлежат какой-то конкретной. При возникновении конфликтов смена ветви не произойдет и позволит избежать потери изменений в файлах.
- для переименовании ветки необходимо использовать:
	$git branch -m old_name new_name - изменяет название ветки с old_name на new_name
- для удаления ветвей используются:
	$git branch -d branch_name - удаление ветки branch_name
	$git branch -D branch_name - принудительное удаление ветки branch_name
- для добавления изменений в удаленный репозиторий применяются:
	$git push - пуш текущего HEAD в удаленный репозиторий 
	$git push origin branch_name - пуш текущей ветки в branch_name удаленного репозитория
	$git push origin branch_name:master - пуш branch_name в master удаленного репозитория
- для сравнения веток используется команда:
	$git diff master your_branch - сравнение master с your_branch и вывод изменений

Comparing changes

- для сравнения применяется:
	$git diff - отображает изменение в working tree в сравнении со staging area
	$git diff --cached - отображает изменения в staging area в сравнении с прошлым коммитом
	$git diff commit1 commit2 - отображает разницу между двумя коммитами
	$git diff  -- file - отображет измение файла test в working tree в сравнении со staging area

Analizing the commit history

- для просмотра истории коммитов применяется:
	$git log - выводит историю коммитов
	$git log HEAD~3 - выводит историю коммитов начиная с 4-го
	$git log commit - выводит историю коммитов начиная с commit
- для команды diff могут применяться различные параметры:
	$git log --oneline - выводит краткую информацию (по одной строке на коммит)
	$git log --abbrev-commit - выводит историю коммитов с краткими идентификаторами SHA-1 (по умолчанию 7 символов)
	$git log --graph --oneline - рисует графическое представление ветвей и истории мержей
- для просмотра истории коммитов для файла применяются:
	$git log -- file - выводит историю коммитов для файла file
	$git log -p -- file - выводит изменение файла file в каждом коммите
- для фильтрации коммитов по имени используется:
	$git log --grep="pattern" - вывод коммитов, в названии которых есть pattern
	$git log --invert-grep="pattern" - вывод коммитов, вназвании которых нет pattern
- для фильтрации коммитов по имени автора применяется:
	$git log --author="pattern" - вывод коммитов, в имени автора которых содержится pattern

Viewing changes

- для просмотра изменений коммита применяется:
	$git show commit_id - выводит изменения коммита с commit_id
- для сравнения двух коммитов используется:
	$git diff HEAD~1 HEAD - вывод разницу между коммитами HEAD~1 и HEAD (можно использовать хеши коммитов)
	$git diff HEAD~2..HEAD - выводит изменения в диапазоне между HEAD~2 и HEAD
	$git diff --name-only HEAD~2..HEAD - выводит лишь имена измененных файлов в диапазоне между HEAD~2 и HEAD

Analizing changes

- для просмотра информации об изменении файла используется:
	$git blame filename - построчно выводит информацию о внесенных изменениях в filename
	$git blame -L 1,2 filename - выводит информацию о внесенных изменениях в 1 и 2 строках

Shortlog

- для вывод краткого содержания лога применяется:
	$git shortlog - выводит автора и название коммита
	$git shortlog -s - выводит количество коммитов пользователя
	$git shortlog -n - выводит список коммитов по номеру вместо имени автора
	$git shortlog --author="pattern" - выводит коммиты автора с именем pattern

Stashing

- для сохранения незакоммиченных изменений используется:
	$git stash - сохраняет изменение из staging area
	$git stash -a - сохраняет все незакоммиченные изменения
- для возврата сохраненных изменений применяется:
	$git stash pop - возвращает ранее сохраненные изменения 
- для просмотра сохраненных изменений:
	$git stash list - выводит список сохраненных изменений вместе с ID
- для очистки сохраненных изменений
	$git stash clear
- для создания новой ветки используя сохраненные изменения
	$git stash branch branchname - создает новую ветку branchname применяя сохраненные изменения

Removing untracked files

- для удаления неотслеживаемых файлов применяется:
	$git clean -n - отображает что произойдет при выполнении git clean
	$git clean -fdx - безвозвратно удаляет неотслеживаемые изменения
	- -f - удаляет неотслежвемые файлы
	- -d - удаляет новые директории
	- -x - удаляет скрытые файлы
		Флаги -d и -x опциональны
	$git clean file4 -fxd - удаляет file4 из неотслеживемых изменений
	
Reverting uncommited changes 

- для удаления файлов из staging area применяется:
	$git reset file - удаляет file из staging area
	$git reset . - удаляет все файлы из staging area
- для восстановления изменений из последнего коммита используется:
	$git checkout -- file - восстановит версию последнего коммита для file в случае если файл не отслеживается или восстановит его в случае удаления
	$git checkout -- data - восстановит контент папки data
- для восставления изменений файла из working tree или staging area:
	$git checkout HEAD -- file - восстановит версию файла file из HEAD
	
Moving branch pointer

- для перемещения указателей используется:
	$git reset работает с параметрами по умолчанию HEAD --mixed
	$git reset HEAD --mixed - аналогично строке выше
	Применяется 3 варианта:
	- --hard - безвозвратно удаляет все измнения из working tree и staging area, возвращая версию HEAD
	- --mixed - staging area сбрасывается, а незакоммиченные изменения переносятся в working tree
	- --soft - выполеняется перестановка указателя на коммит, хеш которого был передан, а изменения из git directory сбрасываются в staging area

Reverting changes

- для отмены изменений определенного коммита используется:
	$ git revert commit - сравнивает изменения commit с его родителем и отменяет изменения commit создавая при этом новый коммит

Recovering commits

- для отображения всех коммитов применяется:
	$git reflog - выводит записи движения указателя HEAD
	Позволяет увидеть историю, включая записи об операциях reset, amend и даже checkout, которые не будут отображаться при выполнении git log

Tracking branches

- для удаления удаленной ветки в локльном репозитории используется:
	$git branch -d -r origin/branch_name - удаляет ветку branch_name
	Данная команда не затрагивает удаленный репозиторий и при выполнении $git fetch удаленная ветка будет пересоздана
- для удаления ветки в удаленном репозитории используется:
	$git push origin --delete branch_name - удаляет ветку branch_name в origin
- для создания локальной ветки, отслеживающей удаленнуюможно применять:
	$git checkout -b new_branch origin/branch - создает ветку new_branch на основе origin/branch и выбирает ее
	$git branch --track new_branch origing/branch - создает ветку new_branch на основе origin/branch
- для установки отслеживания ветки применяется:
	$git branch -u origin/branch branch - branch начинает отслеживать ветку origin/branch
- для просмотра отслеживаемых ветвей удаленного репозитория используется:
	$git remote show origin

Updating remote-tracking branches

- для обновления локальной копии удаленной ветки используется:
	$git fetch origin - обновляет отслеживаемые ветки из удаленного репозитория origin(собирает все коммиты из удаленной ветки, которых нет в текущей и сохраняет в локальном репозитории)
	Стоит отметить что команда затрагивает только отслеживаемые ветки и не изменяет working tree, поэтому ее можно выполнять в любое время.
- для обновления отслеживаемых ветвей для всех удаленных репозиториев применяется:
	$git remote update - выполняет git fetch для всех удаленных репозиториев
	$git remote update --prune - аналогично, но удаляет ветки, которых нет в удаленных репозиториях
В отличие git fetch команда git pull выполняет git fetch и git merge(git rebase). git fetch не выполняет никаких операций над локальными ветвями.

Merging

- Fast-forward merge происходит в случае когда коммит является потомком текущей ветки, при этом виде мержа указатель HEAD текущей ветки перемещается на вершину сливаемой ветки.
- Merge commit используется при слиянии коммитов не являющимися прямыми  потомками текущей ветки. В этом случае на основе объединяемых ветвей создается merge commit, указывающий на своих предшественников
- При мерже используются несколько мерж стратегий:
	- merge commit
	- octopus merge - позволяет одновременно объединять 3 и более ветвей, но также может вызывать большее количество мерж конфликтов. Выполняется следующим образом: $git merge branch1 branch2 branch3 - мержит изменения из трех ветвей в текущую
	- subtree - полезен при необходимости объеденить другой проект с подкаталогом текущего проекта.
	- ours - позволяет слить истории веток проигнорировав изменения внесенные во вмерживаемую ветку.
- для выполения мержа используется:
	$git merge branch - мержит изменения из branch в текущую ветку
- для задания стратегии мержа используется флаг:
	$git merge -s ours branch - использует стратегию ours при сливании (игнорирует все изменения ветки branch)
	Для применения стратегии octopus задаются несколько ветвей в качестве аргументов: $git merge branch1 branch2 branch3
- для рекурсивной (по умолчанию) стратегии слияния можно использовать различные параметры:
	$git merge -s recursive -X ours branch_name - использует изменения текущей ветки при возникновении конфликтов
	$git merge -s recursive -X theirs branch_name - использует изменения branch_name ветки при возникновении конфликтов 
	$git merge -s recursive -Xignore-space-change branch_name - игнорирует изменения пробелов
- для явного использования мержа с помощью коммита в ситуациях, когда будет происходить fast-forward merge необходимо задать: git merge --no-ff

Rebasing branches

При выполнении rebase ветка, в которую мы делаем ребейз, окажется после всех коммитов другой ветки (как правило master). В сравнении с merge позволяет поддерживать историю в более аккратном виде, благодаря отсутствию мерж коммитов. Но данный подход неудобен при работе нескольких людей над одной веткой, так как при ребейзе полностью переписывается история коммитов с заданием новых хешей.
- для выполнения ребейза применяется:
	$git rebase branch - выполняет ребейз branch в текущую ветку
- если необходимо переписать историю изменений в удаленном репозитории, то используется:
	$git push -f
- при необходимости другим людям обновить ребейзнутую ветку используется:
	$git fetch -f

Interactive rebase

Интерактивный ребейз позволяет редактировать историю коммитов: объединять несколько коммитов в один, изменить порядок коммитов или пропустить их и изменить сообщение коммита.
Возможны следующие действия:
- pick - включает выбранный коммит и позволяет изменить порядок коммитов
- skip - удаляет коммит
- edit - редактирует коммит
- squash - объединят коммит с предыдущим вместе с их сообщениями
- fixup - сжимает изменения коммита в предыдущий, отбрасывая сообщение
- reword - аналогично pick, но позволяет редактировать сообщение коммита
Для выполнения интерактивного ребейза используется:
	$git rebase -i  HEAD~3 - применят интерактивный ребейз к 3-м последним коммитам

Cherry-pick

Команда git cherry-pick позволяет выбрать исправление в виде отдельного коммита и применить его к другой ветке, при этом исправление будет представлено отдельным коммитом.
- для выполенения cherry-pick применяется:
	$git cherry-pick commit_id  - создает новый коммит, применяя изменения commit_d
	$git cherry-pick commit_id1..commit_id2 - выполняет cherry-pick для диапазона коммитов
- для отмены cherry-pick необходимо использовать:
	$git cherry-pick --abort

Resolve conflicts

Мерж конфликты возникают, когда 2 коммита из разных ветвей изменяют один и тот же контент и git не может автоматически определить как сочетаются изменения при мерже. При мозникновении мерж конфликта git помечает файлы, в которых возникла проблема, их необходимо устранить вручную, добавить в staging area и закоммитить.
При решении мерж конфликтов иногдавозникает необходимость выбрать одну версию из файлов, это можно сделать с помощью следующей команды:
	$git checkout --ours file.java - выбирает версию файла, который мержится
	$git checkout --theirs file.java - выбирает версию файла, который был до начала операции мержа
Для создания мерж конфликта можно создать 2 ветки от master и в обеих ветках изменить один и тот же файл. Затем замержить одну из веток, при попытке замержить вторую возникнет ошибка. Для решения проблемы необходимо обновить вторую ветку от master:
	$git fetch
	$git merge master
	затем необходимо локально решить все конфликты и закоммитить.
В файле конфликт будет отображен следующим образом:
	<<<<<<< HEAD
	Change in your branch
	==========
	Change in merged branch
	>>>>>>> commit_id
При решении мерж конфликтов с помощью rebase необходимо аналогично вручную решать возникшие конфликты, добавить файлы в staging area и для продолжения выполнения операции выполнить: $git rebase --continue
Для прерывания выполнения ребейза используется: $git rebase --abort

Alias

Alias в Git позволяет создать короткую форму для выполнения одной или нескольких git команд.
- создание alias происходит следующим образом:
	$git config --global alias.lol 'log --oneline' - создает alias 'lol для выполнения 'log --oneline'
	git config --global alias.
- для удаления alias используется:
	$git config --global --unset alias.name
- для создания alias'а, совмещающего несколько команд используется:
	$git config --global alias.act '!git add . -A && git commit' - создает alias 'act' для выполения 'git add . -A && git commit' 

Useful materials

https://www.vogella.com/tutorials/Git/article.html#using-the-git-cherry-pick-command
https://medium.com/@durgaswaroop/understanding-git-octopus-merge-af8b9c688e84
https://www.youtube.com/watch?v=d5rvy5XPyzk


